<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapillary Viewer with Map</title>
    
    <!-- MapillaryJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
    <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
    
    <!-- MapLibre GL -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
        }
        #map {
            width: 50%;
            height: 100%;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 13px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div id="status">Loading images...</div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        const TOKEN = 'MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d';
        const START_ID = '744575191439794';
        const USERNAME = 'HKocen';
        const MAX_POINTS = 50;
        
        let imageData = [];
        let isUpdatingFromViewer = false;
        let isUpdatingFromMap = false;
        let updateTimeout = null;
        let isFetching = false;
        let lastFetchCenter = null;
        let lastFetchZoom = null;
        
        const status = (text) => {
            document.getElementById('status').textContent = text;
        };

        // Initialize Mapillary Viewer
        const viewer = new mapillary.Viewer({
            container: 'viewer',
            accessToken: TOKEN,
            imageId: START_ID,
            component: {
                cover: false,
                sequence: true,
                direction: true,
                zoom: true
            }
        });

        // Initialize MapLibre map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [
                    { id: 'osm', type: 'raster', source: 'osm' }
                ]
            },
            center: [-91.965153, 30.138307],
            zoom: 17
        });

        // Fetch user images from Graph API - closest to center
        async function fetchUserImages() {
            if (isFetching) return;
            
            const currentCenter = map.getCenter();
            const currentZoom = map.getZoom();
            
            // Check if we need to update (zoom changed or panned significantly)
            if (lastFetchCenter && lastFetchZoom !== null) {
                const zoomChanged = Math.abs(currentZoom - lastFetchZoom) >= 0.5;
                const distance = getDistance(
                    lastFetchCenter.lat, lastFetchCenter.lng,
                    currentCenter.lat, currentCenter.lng
                );
                // Only update if zoomed or moved more than 50 meters
                if (!zoomChanged && distance < 50) {
                    console.log('Skipping fetch - zoom diff:', Math.abs(currentZoom - lastFetchZoom), 'distance:', distance.toFixed(1) + 'm');
                    return;
                }
                console.log('Refetching - zoom diff:', Math.abs(currentZoom - lastFetchZoom), 'distance:', distance.toFixed(1) + 'm');
            }
            
            isFetching = true;
            lastFetchCenter = currentCenter;
            lastFetchZoom = currentZoom;
            
            try {
                status('Fetching closest images...');
                
                // Create a bounding box based on zoom level
                const radiusMeters = getRadiusForZoom(currentZoom);
                const bounds = getBoundsFromCenter(currentCenter.lat, currentCenter.lng, radiusMeters);
                const bbox = `${bounds.west},${bounds.south},${bounds.east},${bounds.north}`;
                
                console.log(`Searching bbox with ~${radiusMeters}m radius from center`);
                
                const url = new URL('https://graph.mapillary.com/images');
                url.searchParams.set('access_token', TOKEN);
                url.searchParams.set('fields', 'id,geometry,compass_angle,sequence,captured_at');
                url.searchParams.set('creator_username', USERNAME);
                url.searchParams.set('bbox', bbox);
                url.searchParams.set('limit', 2000); // Fetch more to ensure we get some
                
                const response = await fetch(url);
                if (!response.ok) {
                    console.error(`HTTP ${response.status}: ${await response.text()}`);
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                let allImages = data.data || [];
                
                console.log(`API returned ${allImages.length} images`);
                
                // If no images found, try expanding the search
                if (allImages.length === 0) {
                    console.log('No images found, trying larger area...');
                    const largerRadius = radiusMeters * 3;
                    const largerBounds = getBoundsFromCenter(currentCenter.lat, currentCenter.lng, largerRadius);
                    const largerBbox = `${largerBounds.west},${largerBounds.south},${largerBounds.east},${largerBounds.north}`;
                    
                    const url2 = new URL('https://graph.mapillary.com/images');
                    url2.searchParams.set('access_token', TOKEN);
                    url2.searchParams.set('fields', 'id,geometry,compass_angle,sequence,captured_at');
                    url2.searchParams.set('creator_username', USERNAME);
                    url2.searchParams.set('bbox', largerBbox);
                    url2.searchParams.set('limit', 2000);
                    
                    const response2 = await fetch(url2);
                    if (response2.ok) {
                        const data2 = await response2.json();
                        allImages = data2.data || [];
                        console.log(`Larger search returned ${allImages.length} images`);
                    }
                }
                
                if (allImages.length === 0) {
                    status('No images nearby - try zooming out');
                    imageData = [];
                    if (map.getSource('images')) {
                        map.getSource('images').setData({ type: 'FeatureCollection', features: [] });
                    }
                    if (map.getSource('sequences')) {
                        map.getSource('sequences').setData({ type: 'FeatureCollection', features: [] });
                    }
                    isFetching = false;
                    return;
                }
                
                // Calculate distance for each image and sort by distance
                allImages.forEach(img => {
                    if (img.geometry && img.geometry.coordinates) {
                        const [lng, lat] = img.geometry.coordinates;
                        img.distance = getDistance(currentCenter.lat, currentCenter.lng, lat, lng);
                    } else {
                        img.distance = Infinity;
                    }
                });
                
                // Sort by distance and take closest MAX_POINTS
                allImages.sort((a, b) => a.distance - b.distance);
                imageData = allImages.slice(0, MAX_POINTS);
                
                console.log(`Showing ${imageData.length} closest images (max distance: ${imageData[imageData.length-1]?.distance?.toFixed(1)}m)`);
                
                status(`Loaded ${imageData.length} closest images`);
                addImagesToMap();
            } catch (err) {
                status('Error loading images: ' + err.message);
                console.error('Error fetching images:', err);
            } finally {
                isFetching = false;
            }
        }
        
        // Get bounding box from center point and radius
        function getBoundsFromCenter(lat, lng, radiusMeters) {
            const latDelta = (radiusMeters / 111320); // 1 degree lat ≈ 111.32 km
            const lngDelta = (radiusMeters / (111320 * Math.cos(lat * Math.PI / 180)));
            
            return {
                north: lat + latDelta,
                south: lat - latDelta,
                east: lng + lngDelta,
                west: lng - lngDelta
            };
        }
        
        // Calculate distance between two points in meters
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Earth radius in meters
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                    Math.cos(φ1) * Math.cos(φ2) *
                    Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // Get appropriate search radius based on zoom level
        function getRadiusForZoom(zoom) {
            if (zoom >= 18) return 500;
            if (zoom >= 17) return 1000;
            if (zoom >= 16) return 2000;
            if (zoom >= 15) return 4000;
            if (zoom >= 14) return 8000;
            return 15000;
        }

        // Update map points
        function updateMapPoints(features) {
            if (map.getSource('images')) {
                map.getSource('images').setData({
                    type: 'FeatureCollection',
                    features: features
                });
            }
        }

        // Add images to map as GeoJSON
        function addImagesToMap() {
            const features = [];
            const sequenceGroups = {};
            
            // Single pass through data to build both features and sequence groups
            for (const img of imageData) {
                if (!img.geometry || !img.geometry.coordinates) continue;
                
                const coords = img.geometry.coordinates;
                
                // Add point feature
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coords
                    },
                    properties: {
                        id: img.id,
                        compass_angle: img.compass_angle || 0,
                        sequence: img.sequence || null
                    }
                });
                
                // Group for sequences
                if (img.sequence) {
                    if (!sequenceGroups[img.sequence]) {
                        sequenceGroups[img.sequence] = [];
                    }
                    sequenceGroups[img.sequence].push({
                        coords: coords,
                        captured_at: img.captured_at
                    });
                }
            }

            // Create line features from sequences
            const lineFeatures = [];
            for (const [seqId, points] of Object.entries(sequenceGroups)) {
                if (points.length < 2) continue; // Skip single-point sequences
                
                // Sort by capture time if available
                if (points[0].captured_at) {
                    points.sort((a, b) => new Date(a.captured_at) - new Date(b.captured_at));
                }
                
                lineFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: points.map(p => p.coords)
                    },
                    properties: {
                        sequence: seqId
                    }
                });
            }

            console.log(`Adding ${features.length} points and ${lineFeatures.length} lines to map`);

            // Update the sources
            if (map.getSource('images')) {
                map.getSource('images').setData({
                    type: 'FeatureCollection',
                    features: features
                });
            }
            
            if (map.getSource('sequences')) {
                map.getSource('sequences').setData({
                    type: 'FeatureCollection',
                    features: lineFeatures
                });
            }
        }

        // Schedule map update on pan/zoom
        function scheduleMapUpdate() {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                fetchUserImages();
            }, 500);
        }

        // FOV indicator
        function makeArcPath(fovDeg) {
            const r = 45, cx = 50, cy = 50;
            const rad = Math.PI / 180 * fovDeg;
            const a0 = -Math.PI / 2 - rad / 2;
            const a1 = a0 + rad;
            const x0 = cx + r * Math.cos(a0);
            const y0 = cy + r * Math.sin(a0);
            const x1 = cx + r * Math.cos(a1);
            const y1 = cy + r * Math.sin(a1);
            return `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
        }

        function makeCamera(bearingDeg, fovDeg) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', makeArcPath(fovDeg));
            path.setAttribute('fill', '#4285F4');
            path.setAttribute('fill-opacity', '0.5');
            path.setAttribute('stroke', 'white');
            path.setAttribute('stroke-width', '2');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.appendChild(path);
            svg.style.height = '100%';
            svg.style.width = '100%';
            svg.style.transform = `rotateZ(${bearingDeg}deg)`;
            
            const el = document.createElement('div');
            el.style.height = '80px';
            el.style.width = '80px';
            el.appendChild(svg);
            return el;
        }

        const cameraEl = makeCamera(0, 90);
        const cameraMarker = new maplibregl.Marker({
            element: cameraEl,
            rotationAlignment: 'map'
        });

        const posDot = document.createElement('div');
        posDot.style.cssText = 'width:14px;height:14px;border:3px solid #EA4335;border-radius:50%;background:#fff;';
        const positionMarker = new maplibregl.Marker({
            element: posDot,
            rotationAlignment: 'map'
        });

        // Sync viewer position to map
        async function syncPosition() {
            if (isUpdatingFromMap) return;
            
            try {
                isUpdatingFromViewer = true;
                const pos = await viewer.getPosition();
                const pov = await viewer.getPointOfView();
                
                // Update position markers
                positionMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                cameraMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                
                // Update FOV rotation
                const svg = cameraEl.querySelector('svg');
                if (svg) {
                    svg.style.transform = `rotateZ(${pov.bearing}deg)`;
                }
                
                // Update highlighted point
                if (map.getSource('currentImage')) {
                    map.getSource('currentImage').setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [pos.lng, pos.lat]
                            }
                        }]
                    });
                }
                
                // Only pan if we're not already updating from a map click
                if (!isUpdatingFromMap) {
                    map.panTo([pos.lng, pos.lat]);
                }
                
                setTimeout(() => { isUpdatingFromViewer = false; }, 200);
            } catch (err) {
                console.error('Error syncing position:', err);
                isUpdatingFromViewer = false;
            }
        }

        // Update FOV when it changes
        viewer.on('fov', async () => {
            try {
                const vc = viewer.getContainer();
                const vFov = Math.PI / 180 * (await viewer.getFieldOfView());
                const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
                const hFovDeg = Math.atan(aspect * Math.tan(0.5 * vFov)) * 2 * 180 / Math.PI;
                const path = cameraEl.querySelector('path');
                if (path) {
                    path.setAttribute('d', makeArcPath(hFovDeg));
                }
            } catch (err) {
                console.error('Error updating FOV:', err);
            }
        });

        // Set up viewer event listeners
        viewer.on('load', syncPosition);
        viewer.on('image', syncPosition);
        viewer.on('position', syncPosition);
        viewer.on('pov', syncPosition);

        window.addEventListener('resize', () => {
            if (viewer.emit) viewer.emit('fov');
        });

        // Initialize when map loads
        map.on('load', () => {
            // Create empty sources first
            map.addSource('sequences', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'sequence-lines',
                type: 'line',
                source: 'sequences',
                paint: {
                    'line-color': '#4285F4',
                    'line-width': 2,
                    'line-opacity': 0.6
                }
            });

            map.addSource('images', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'image-points',
                type: 'circle',
                source: 'images',
                paint: {
                    'circle-color': '#4285F4',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 3, 18, 8],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#fff',
                    'circle-opacity': 0.8
                }
            });

            map.addSource('currentImage', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });
            
            map.addLayer({
                id: 'current-image',
                type: 'circle',
                source: 'currentImage',
                paint: {
                    'circle-color': '#EA4335',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 5, 18, 12],
                    'circle-stroke-width': 3,
                    'circle-stroke-color': '#fff'
                }
            });

            // Click handler
            map.on('click', 'image-points', async (e) => {
                if (isUpdatingFromViewer) return;
                
                const feature = e.features[0];
                const imageId = feature.properties.id;
                const coords = feature.geometry.coordinates;
                
                if (imageId) {
                    isUpdatingFromMap = true;
                    
                    // Update highlighted point immediately
                    if (map.getSource('currentImage')) {
                        map.getSource('currentImage').setData({
                            type: 'FeatureCollection',
                            features: [{
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: coords
                                }
                            }]
                        });
                    }
                    
                    // Update position markers immediately
                    positionMarker.setLngLat(coords).addTo(map);
                    cameraMarker.setLngLat(coords).addTo(map);
                    
                    // Center map on selected point
                    map.panTo(coords);
                    
                    try {
                        await viewer.moveTo(String(imageId));
                        // Force a position sync after the image loads
                        setTimeout(syncPosition, 100);
                    } catch (err) {
                        console.error('Error moving to image:', err);
                    }
                    setTimeout(() => { isUpdatingFromMap = false; }, 300);
                }
            });

            map.on('mouseenter', 'image-points', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'image-points', () => {
                map.getCanvas().style.cursor = '';
            });

            // Now fetch images
            fetchUserImages();
        });

        // Update points when map moves
        map.on('moveend', scheduleMapUpdate);
        map.on('zoomend', scheduleMapUpdate);
    </script>
</body>
</html>
