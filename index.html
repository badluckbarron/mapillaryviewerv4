<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapillary Viewer with Map</title>
    <link href='https://unpkg.com/mapillary-js@4.1.2/dist/mapillary.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
        }
        #map {
            width: 50%;
            height: 100%;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 25%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div class="loading" id="loading">Loading Mapillary images...</div>
        </div>
        <div id="map"></div>
    </div>

    <script src='https://unpkg.com/mapillary-js@4.1.2/dist/mapillary.js'></script>
    <script>
        const accessToken = 'MLY|24584288231255151|0d9a69d96c271db6f1804afa84147c66';
        const username = 'HKocen';
        const startImageId = '744575191439794';
        
        let viewer;
        let map;
        let markers = {};
        let currentMarker = null;
        let fovMarker = null;
        let imageData = [];
        let isUpdatingFromViewer = false;
        let isUpdatingFromMap = false;

        // Initialize Leaflet map
        map = L.map('map').setView([0, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // Create custom icon for FOV
        const createFOVIcon = (bearing) => {
            const svg = `
                <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(20,20) rotate(${bearing})">
                        <circle cx="0" cy="0" r="6" fill="#4285F4" stroke="white" stroke-width="2"/>
                        <path d="M 0,-6 L -8,-20 L 8,-20 Z" fill="#4285F4" opacity="0.6" stroke="white" stroke-width="1"/>
                    </g>
                </svg>
            `;
            return L.divIcon({
                html: svg,
                className: 'fov-marker',
                iconSize: [40, 40],
                iconAnchor: [20, 20]
            });
        };

        // Initialize Mapillary Viewer after ensuring library is loaded
        function initializeViewer() {
            if (typeof Mapillary === 'undefined') {
                setTimeout(initializeViewer, 100);
                return;
            }
            
            viewer = new Mapillary.Viewer({
                accessToken: accessToken,
                container: 'viewer',
                imageId: startImageId,
                component: {
                    cover: false,
                    sequence: {minWidth: 100, maxWidth: 200, visible: true}
                }
            });

            setupViewerEvents();
            fetchUserImages();
        }

        // Setup viewer event listeners
        function setupViewerEvents() {
            // Update map when viewer position changes
            viewer.on('image', (event) => {
                if (isUpdatingFromMap) return;
                
                isUpdatingFromViewer = true;
                const imageId = event.image.id;
                
                // Find image data
                const imgData = imageData.find(img => img.id === imageId);
                if (!imgData || !imgData.computed_geometry) {
                    isUpdatingFromViewer = false;
                    return;
                }

                const [lng, lat] = imgData.computed_geometry.coordinates;
                const bearing = imgData.computed_compass_angle || 0;

                // Update current marker style
                if (currentMarker) {
                    currentMarker.setStyle({
                        fillColor: '#4285F4',
                        radius: 5
                    });
                }

                if (markers[imageId]) {
                    currentMarker = markers[imageId];
                    currentMarker.setStyle({
                        fillColor: '#EA4335',
                        radius: 7
                    });
                }

                // Update FOV marker
                if (fovMarker) {
                    map.removeLayer(fovMarker);
                }
                
                fovMarker = L.marker([lat, lng], {
                    icon: createFOVIcon(bearing),
                    zIndexOffset: 1000
                }).addTo(map);

                // Center map on current position
                map.panTo([lat, lng]);
                
                setTimeout(() => { isUpdatingFromViewer = false; }, 100);
            });

            // Update FOV when bearing changes
            viewer.on('bearing', (event) => {
                if (!fovMarker) return;
                
                const bearing = event.bearing;
                const latLng = fovMarker.getLatLng();
                
                map.removeLayer(fovMarker);
                fovMarker = L.marker(latLng, {
                    icon: createFOVIcon(bearing),
                    zIndexOffset: 1000
                }).addTo(map);
            });
        }

        // Fetch images from Mapillary API
        async function fetchUserImages() {
            try {
                const response = await fetch(
                    `https://graph.mapillary.com/images?access_token=${accessToken}&fields=id,computed_geometry,computed_compass_angle,captured_at&creator_username=${username}&limit=2000`
                );
                const data = await response.json();
                imageData = data.data || [];
                
                if (imageData.length === 0) {
                    document.getElementById('loading').textContent = 'No images found for user ' + username;
                    return;
                }

                // Find starting image to center map
                const startImg = imageData.find(img => img.id === startImageId);
                let startLat = 0, startLng = 0;
                
                if (startImg && startImg.computed_geometry) {
                    [startLng, startLat] = startImg.computed_geometry.coordinates;
                    map.setView([startLat, startLng], 16);
                }

                // Add markers to map
                imageData.forEach(img => {
                    if (img.computed_geometry && img.computed_geometry.coordinates) {
                        const [lng, lat] = img.computed_geometry.coordinates;
                        const marker = L.circleMarker([lat, lng], {
                            radius: 5,
                            fillColor: '#4285F4',
                            color: '#fff',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.7
                        }).addTo(map);
                        
                        marker.on('click', () => {
                            if (!isUpdatingFromViewer) {
                                isUpdatingFromMap = true;
                                viewer.moveTo(img.id).then(() => {
                                    setTimeout(() => { isUpdatingFromMap = false; }, 100);
                                }).catch(() => {
                                    isUpdatingFromMap = false;
                                });
                            }
                        });
                        
                        markers[img.id] = marker;
                    }
                });

                // If no starting image found, fit to all markers
                if (!startImg && imageData.length > 0) {
                    const bounds = Object.values(markers).map(m => m.getLatLng());
                    if (bounds.length > 0) {
                        map.fitBounds(L.latLngBounds(bounds), { padding: [50, 50] });
                    }
                }

                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error fetching images:', error);
                document.getElementById('loading').textContent = 'Error loading images: ' + error.message;
            }
        }

        // Start initialization
        initializeViewer();
    </script>
</body>
</html>
