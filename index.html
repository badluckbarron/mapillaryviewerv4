<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapillary Viewer with Map</title>
    
    <!-- MapillaryJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
    <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
    
    <!-- MapLibre GL -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
        }
        #map {
            width: 50%;
            height: 100%;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 13px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div id="status">Loading images...</div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        const TOKEN = 'MLY|24840280672250420|6fc0e204403850a11ccc043866f1b01d';
        const START_ID = '1347465910083369';
        const USERNAME = 'vukmercd23';
        const START_DATE = '2024-10-01T00:00:00Z';
        const END_DATE = '2024-10-16T00:00:00Z'; // Exclusive, so 10/15 23:59:59 is included
        
        let imageData = [];
        let isUpdatingFromViewer = false;
        let isUpdatingFromMap = false;
        
        const status = (text) => {
            document.getElementById('status').textContent = text;
        };

        // Initialize Mapillary Viewer
        const viewer = new mapillary.Viewer({
            container: 'viewer',
            accessToken: TOKEN,
            imageId: START_ID,
            component: {
                cover: false,
                sequence: true,
                direction: true,
                zoom: true
            }
        });

        // Initialize MapLibre map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: 'raster',
                        tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: 'Â© OpenStreetMap contributors'
                    }
                },
                layers: [
                    { id: 'osm', type: 'raster', source: 'osm' }
                ]
            },
            center: [0, 0],
            zoom: 2
        });

        // Fetch ALL user images with date filter
        async function fetchAllUserImages() {
            try {
                status('Loading all images...');
                
                let allImages = [];
                let after = null;
                let requestCount = 0;
                const startTime = Date.parse(START_DATE);
                const endTime = Date.parse(END_DATE);
                
                // Fetch all pages
                while (true) {
                    const url = new URL('https://graph.mapillary.com/images');
                    url.searchParams.set('access_token', TOKEN);
                    url.searchParams.set('fields', 'id,geometry,compass_angle,sequence,captured_at');
                    url.searchParams.set('creator_username', USERNAME);
                    url.searchParams.set('start_captured_at', START_DATE);
                    url.searchParams.set('end_captured_at', END_DATE);
                    url.searchParams.set('limit', 2000);
                    if (after) {
                        url.searchParams.set('after', after);
                    }
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`HTTP ${response.status}: ${await response.text()}`);
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const images = data.data || [];
                    
                    requestCount++;
                    console.log(`Request ${requestCount}: got ${images.length} images`);
                    
                    if (images.length === 0) break;
                    
                    // Filter by date (double-check since API filtering might not be perfect)
                    const filtered = images.filter(img => {
                        if (!img.captured_at) return false;
                        const capturedTime = Date.parse(img.captured_at);
                        return capturedTime >= startTime && capturedTime < endTime;
                    });
                    
                    allImages = allImages.concat(filtered);
                    status(`Loaded ${allImages.length} images...`);
                    
                    // Check if there's more data
                    if (data.paging && data.paging.cursors && data.paging.cursors.after) {
                        after = data.paging.cursors.after;
                    } else {
                        console.log('No more pages available');
                        break;
                    }
                }
                
                console.log(`Total images fetched: ${allImages.length} in ${requestCount} requests`);
                imageData = allImages;
                
                if (imageData.length === 0) {
                    status('No images found for date range');
                    return;
                }
                
                status(`Loaded ${imageData.length} images (Oct 1-15)`);
                addImagesToMap();
                
                // Fit map to show all points
                if (imageData.length > 0) {
                    const coords = imageData
                        .filter(img => img.geometry && img.geometry.coordinates)
                        .map(img => img.geometry.coordinates);
                    
                    if (coords.length > 0) {
                        const bounds = coords.reduce((bounds, coord) => {
                            return bounds.extend(coord);
                        }, new maplibregl.LngLatBounds(coords[0], coords[0]));
                        
                        map.fitBounds(bounds, { padding: 50 });
                    }
                }
            } catch (err) {
                status('Error loading images: ' + err.message);
                console.error('Error fetching images:', err);
            }
        }

        // Add images to map as GeoJSON
        function addImagesToMap() {
            const features = [];
            const sequenceGroups = {};
            
            // Single pass through data to build both features and sequence groups
            for (const img of imageData) {
                if (!img.geometry || !img.geometry.coordinates) continue;
                
                const coords = img.geometry.coordinates;
                
                // Add point feature
                features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coords
                    },
                    properties: {
                        id: img.id,
                        compass_angle: img.compass_angle || 0,
                        sequence: img.sequence || null
                    }
                });
                
                // Group for sequences
                if (img.sequence) {
                    if (!sequenceGroups[img.sequence]) {
                        sequenceGroups[img.sequence] = [];
                    }
                    sequenceGroups[img.sequence].push({
                        coords: coords,
                        captured_at: img.captured_at
                    });
                }
            }

            // Create line features from sequences
            const lineFeatures = [];
            for (const [seqId, points] of Object.entries(sequenceGroups)) {
                if (points.length < 2) continue;
                
                if (points[0].captured_at) {
                    points.sort((a, b) => new Date(a.captured_at) - new Date(b.captured_at));
                }
                
                lineFeatures.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: points.map(p => p.coords)
                    },
                    properties: {
                        sequence: seqId
                    }
                });
            }

            console.log(`Adding ${features.length} points and ${lineFeatures.length} lines to map`);

            // Update the sources
            if (map.getSource('images')) {
                map.getSource('images').setData({
                    type: 'FeatureCollection',
                    features: features
                });
            }
            
            if (map.getSource('sequences')) {
                map.getSource('sequences').setData({
                    type: 'FeatureCollection',
                    features: lineFeatures
                });
            }
        }

        // FOV indicator
        function makeArcPath(fovDeg) {
            const r = 45, cx = 50, cy = 50;
            const rad = Math.PI / 180 * fovDeg;
            const a0 = -Math.PI / 2 - rad / 2;
            const a1 = a0 + rad;
            const x0 = cx + r * Math.cos(a0);
            const y0 = cy + r * Math.sin(a0);
            const x1 = cx + r * Math.cos(a1);
            const y1 = cy + r * Math.sin(a1);
            return `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
        }

        function makeCamera(bearingDeg, fovDeg) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', makeArcPath(fovDeg));
            path.setAttribute('fill', '#4285F4');
            path.setAttribute('fill-opacity', '0.5');
            path.setAttribute('stroke', 'white');
            path.setAttribute('stroke-width', '2');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.appendChild(path);
            svg.style.height = '100%';
            svg.style.width = '100%';
            svg.style.transform = `rotateZ(${bearingDeg}deg)`;
            
            const el = document.createElement('div');
            el.style.height = '80px';
            el.style.width = '80px';
            el.appendChild(svg);
            return el;
        }

        const cameraEl = makeCamera(0, 90);
        const cameraMarker = new maplibregl.Marker({
            element: cameraEl,
            rotationAlignment: 'map'
        });

        const posDot = document.createElement('div');
        posDot.style.cssText = 'width:14px;height:14px;border:3px solid #EA4335;border-radius:50%;background:#fff;';
        const positionMarker = new maplibregl.Marker({
            element: posDot,
            rotationAlignment: 'map'
        });

        // Sync viewer position to map
        async function syncPosition() {
            if (isUpdatingFromMap) return;
            
            try {
                isUpdatingFromViewer = true;
                const pos = await viewer.getPosition();
                const pov = await viewer.getPointOfView();
                
                // Update position markers
                positionMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                cameraMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                
                // Update FOV rotation
                const svg = cameraEl.querySelector('svg');
                if (svg) {
                    svg.style.transform = `rotateZ(${pov.bearing}deg)`;
                }
                
                // Update highlighted point
                if (map.getSource('currentImage')) {
                    map.getSource('currentImage').setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: [pos.lng, pos.lat]
                            }
                        }]
                    });
                }
                
                // Only pan if we're not already updating from a map click
                if (!isUpdatingFromMap) {
                    map.panTo([pos.lng, pos.lat]);
                }
                
                setTimeout(() => { isUpdatingFromViewer = false; }, 200);
            } catch (err) {
                console.error('Error syncing position:', err);
                isUpdatingFromViewer = false;
            }
        }

        // Update FOV when it changes
        viewer.on('fov', async () => {
            try {
                const vc = viewer.getContainer();
                const vFov = Math.PI / 180 * (await viewer.getFieldOfView());
                const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
                const hFovDeg = Math.atan(aspect * Math.tan(0.5 * vFov)) * 2 * 180 / Math.PI;
                const path = cameraEl.querySelector('path');
                if (path) {
                    path.setAttribute('d', makeArcPath(hFovDeg));
                }
            } catch (err) {
                console.error('Error updating FOV:', err);
            }
        });

        // Set up viewer event listeners
        viewer.on('load', syncPosition);
        viewer.on('image', syncPosition);
        viewer.on('position', syncPosition);
        viewer.on('pov', syncPosition);

        window.addEventListener('resize', () => {
            if (viewer.emit) viewer.emit('fov');
        });

        // Initialize when map loads
        map.on('load', () => {
            // Create empty sources first
            map.addSource('sequences', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'sequence-lines',
                type: 'line',
                source: 'sequences',
                paint: {
                    'line-color': '#4285F4',
                    'line-width': 2,
                    'line-opacity': 0.6
                }
            });

            map.addSource('images', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });

            map.addLayer({
                id: 'image-points',
                type: 'circle',
                source: 'images',
                paint: {
                    'circle-color': '#4285F4',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 3, 18, 8],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#fff',
                    'circle-opacity': 0.8
                }
            });

            map.addSource('currentImage', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });
            
            map.addLayer({
                id: 'current-image',
                type: 'circle',
                source: 'currentImage',
                paint: {
                    'circle-color': '#EA4335',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 12, 5, 18, 12],
                    'circle-stroke-width': 3,
                    'circle-stroke-color': '#fff'
                }
            });

            // Click handler
            map.on('click', 'image-points', async (e) => {
                if (isUpdatingFromViewer) return;
                
                const feature = e.features[0];
                const imageId = feature.properties.id;
                const coords = feature.geometry.coordinates;
                
                if (imageId) {
                    isUpdatingFromMap = true;
                    
                    // Update highlighted point immediately
                    if (map.getSource('currentImage')) {
                        map.getSource('currentImage').setData({
                            type: 'FeatureCollection',
                            features: [{
                                type: 'Feature',
                                geometry: {
                                    type: 'Point',
                                    coordinates: coords
                                }
                            }]
                        });
                    }
                    
                    // Update position markers immediately
                    positionMarker.setLngLat(coords).addTo(map);
                    cameraMarker.setLngLat(coords).addTo(map);
                    
                    // Center map on selected point
                    map.panTo(coords);
                    
                    try {
                        await viewer.moveTo(String(imageId));
                        // Force a position sync after the image loads
                        setTimeout(syncPosition, 100);
                    } catch (err) {
                        console.error('Error moving to image:', err);
                    }
                    setTimeout(() => { isUpdatingFromMap = false; }, 300);
                }
            });

            map.on('mouseenter', 'image-points', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'image-points', () => {
                map.getCanvas().style.cursor = '';
            });

            // Load all images once at startup
            fetchAllUserImages();
        });
    </script>
</body>
</html>
