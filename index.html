<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapillary Viewer with Map</title>
    
    <!-- MapillaryJS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.css" />
    <script src="https://cdn.jsdelivr.net/npm/mapillary-js@latest/dist/mapillary.min.js"></script>
    
    <!-- MapLibre GL -->
    <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: Arial, sans-serif;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        #viewer {
            width: 50%;
            height: 100%;
        }
        #map {
            width: 50%;
            height: 100%;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            font-size: 13px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewer">
            <div id="status">Loading...</div>
        </div>
        <div id="map"></div>
    </div>

    <script>
        const TOKEN = 'MLY|24584288231255151|0d9a69d96c271db6f1804afa84147c66';
        const START_ID = '744575191439794';
        const USERNAME = 'HKocen';
        
        const status = (text) => {
            document.getElementById('status').textContent = text;
        };

        // Initialize Mapillary Viewer
        const viewer = new mapillary.Viewer({
            container: 'viewer',
            accessToken: TOKEN,
            imageId: START_ID,
            component: {
                cover: false,
                sequence: true,
                direction: true,
                zoom: true
            }
        });

        // Initialize MapLibre map
        const mapStyle = {
            version: 8,
            name: 'OSM + Mapillary',
            sources: {
                osm: {
                    type: 'raster',
                    tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                    tileSize: 256,
                    attribution: 'Â© OpenStreetMap contributors'
                },
                mapillary: {
                    type: 'vector',
                    tiles: [
                        `https://tiles.mapillary.com/maps/vtp/mly1_public/2/{z}/{x}/{y}?access_token=${encodeURIComponent(TOKEN)}`
                    ],
                    minzoom: 0,
                    maxzoom: 14
                }
            },
            layers: [
                { id: 'bg', type: 'background', paint: { 'background-color': '#f0f0f0' } },
                { id: 'osm', type: 'raster', source: 'osm' }
            ]
        };

        const map = new maplibregl.Map({
            container: 'map',
            style: mapStyle,
            center: [-91.965153, 30.138307],
            zoom: 15
        });

        // Add Mapillary layers when map loads
        map.on('load', () => {
            // Sequence lines
            map.addLayer({
                id: 'mly-sequences',
                type: 'line',
                source: 'mapillary',
                'source-layer': 'sequence',
                minzoom: 13,
                paint: {
                    'line-color': '#4285F4',
                    'line-opacity': 0.6,
                    'line-width': 2
                }
            });

            // Image points
            map.addLayer({
                id: 'mly-images',
                type: 'circle',
                source: 'mapillary',
                'source-layer': 'image',
                minzoom: 14,
                paint: {
                    'circle-color': '#4285F4',
                    'circle-opacity': 0.8,
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 14, 3, 18, 6],
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#fff'
                }
            });

            // Highlighted image
            map.addSource('currentImage', {
                type: 'geojson',
                data: { type: 'FeatureCollection', features: [] }
            });
            
            map.addLayer({
                id: 'current-image',
                type: 'circle',
                source: 'currentImage',
                paint: {
                    'circle-color': '#EA4335',
                    'circle-radius': ['interpolate', ['linear'], ['zoom'], 14, 5, 18, 10],
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#fff'
                }
            });

            // Click handler for images
            map.on('click', 'mly-images', async (e) => {
                const feature = e.features[0];
                const imageId = feature.properties.id || feature.properties.key;
                if (imageId) {
                    try {
                        await viewer.moveTo(String(imageId));
                    } catch (err) {
                        console.error('Error moving to image:', err);
                    }
                }
            });

            map.on('mouseenter', 'mly-images', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'mly-images', () => {
                map.getCanvas().style.cursor = '';
            });

            status('Ready - Click on points to view images');
        });

        // FOV indicator
        function makeArcPath(fovDeg) {
            const r = 45, cx = 50, cy = 50;
            const rad = Math.PI / 180 * fovDeg;
            const a0 = -Math.PI / 2 - rad / 2;
            const a1 = a0 + rad;
            const x0 = cx + r * Math.cos(a0);
            const y0 = cy + r * Math.sin(a0);
            const x1 = cx + r * Math.cos(a1);
            const y1 = cy + r * Math.sin(a1);
            return `M ${cx} ${cy} L ${x0} ${y0} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
        }

        function makeCamera(bearingDeg, fovDeg) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', makeArcPath(fovDeg));
            path.setAttribute('fill', '#4285F4');
            path.setAttribute('fill-opacity', '0.5');
            path.setAttribute('stroke', 'white');
            path.setAttribute('stroke-width', '2');
            
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 100 100');
            svg.appendChild(path);
            svg.style.height = '100%';
            svg.style.width = '100%';
            svg.style.transform = `rotateZ(${bearingDeg}deg)`;
            
            const el = document.createElement('div');
            el.style.height = '80px';
            el.style.width = '80px';
            el.appendChild(svg);
            return el;
        }

        const cameraEl = makeCamera(0, 90);
        const cameraMarker = new maplibregl.Marker({
            element: cameraEl,
            rotationAlignment: 'map'
        });

        const posDot = document.createElement('div');
        posDot.style.cssText = 'width:14px;height:14px;border:3px solid #EA4335;border-radius:50%;background:#fff;';
        const positionMarker = new maplibregl.Marker({
            element: posDot,
            rotationAlignment: 'map'
        });

        // Sync viewer position to map
        async function syncPosition() {
            try {
                const pos = await viewer.getPosition();
                const pov = await viewer.getPointOfView();
                
                positionMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                cameraMarker.setLngLat([pos.lng, pos.lat]).addTo(map);
                
                const svg = cameraEl.querySelector('svg');
                if (svg) {
                    svg.style.transform = `rotateZ(${pov.bearing}deg)`;
                }
                
                // Update highlighted point
                map.getSource('currentImage').setData({
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [pos.lng, pos.lat]
                        }
                    }]
                });
                
                map.panTo([pos.lng, pos.lat]);
            } catch (err) {
                console.error('Error syncing position:', err);
            }
        }

        // Update FOV when it changes
        viewer.on('fov', async () => {
            try {
                const vc = viewer.getContainer();
                const vFov = Math.PI / 180 * (await viewer.getFieldOfView());
                const aspect = vc.offsetHeight ? vc.offsetWidth / vc.offsetHeight : 0;
                const hFovDeg = Math.atan(aspect * Math.tan(0.5 * vFov)) * 2 * 180 / Math.PI;
                const path = cameraEl.querySelector('path');
                if (path) {
                    path.setAttribute('d', makeArcPath(hFovDeg));
                }
            } catch (err) {
                console.error('Error updating FOV:', err);
            }
        });

        // Set up viewer event listeners
        viewer.on('load', syncPosition);
        viewer.on('image', syncPosition);
        viewer.on('position', syncPosition);
        viewer.on('pov', syncPosition);

        window.addEventListener('resize', () => {
            if (viewer.emit) viewer.emit('fov');
        });
    </script>
</body>
</html>
